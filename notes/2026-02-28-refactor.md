# 2026-02-28 Redis removal + client-side sets

## Findings
- Redis is used for all persistence: items, sets, suggestions, location cache, status.
- Server builds sets in `MediaFiles.load` and `web_app/data.py`; UI consumes server-rendered sets.
- JS scroll logic loads more sets from `/set/more_from/<position>` and relies on server-side set ordering.
- Set gap is hard-coded via `MediaSet(gap=2)`; not in config today.

## Requirements captured
- Remove Redis entirely; use SQLite for persistence (in Docker, DB under `/config`).
- Server must expose items-only API; no server-side set creation.
- Client groups items into sets using a configurable time gap (default 2 hours).
- Client fetches items in pages (~20), enough to render 3 full sets at a time; no partial sets displayed.
- Store item metadata in SQLite (path, timestamp, filename, directory, coords/location cache) for fast API reads.
- Update tests, Docker, docs, and add incremental notes.

## Design decisions
- SQLite schema: `items` (id, path, timestamp, filename, directory, coords, location), `suggestions`, `location_cache`, `meta` for status.
- Items API: `/api/items?limit=20&after_ts=...&after_id=...` ordered oldest to newest by default.
- Client builds sets based on gap hours (config), buffers until a gap is observed, and only renders complete sets.
- Move actions now post item id lists to `/api/set/<action>`; server deletes moved items from SQLite.

## Geo lookup update
- Reverse geocoding now uses Geoapify during scan/populate, keyed by `GEOAPIFY_API_KEY`.
- Cached in SQLite `location_cache`; stored value is `address_line1` when available.
